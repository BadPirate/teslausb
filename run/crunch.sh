#!/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_HELP(["Crunches" the 3 Tesla videos (front, right, left) into a single video for playback and generates a "highlight" reel which shows only video with motion over a specific threshold.])
# ARG_OPTIONAL_SINGLE([motion],[m],[sets a motion threshold for generating highlights],[0.005])
# ARG_POSITIONAL_SINGLE([video],[any of the three videos, should be in same folder as other two])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


begins_with_short_option()
{
	local first_option all_short_options='hm'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_motion="0.005"


print_help()
{
	printf '%s\n' "\"Crunches\" the 3 Tesla videos (front, right, left) into a single video for playback and generates \
   a \"highlight\" reel which shows only video with motion over a specific threshold."
	printf 'Usage: %s [-h|--help] [-m|--motion <arg>] <video>\n' "$0"
	printf '\t%s\n' "<video>: any of the three videos, should be in same folder as other two"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-m, --motion: sets a motion threshold for generating highlights (default: '0.005')"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-m|--motion)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_motion="$2"
				shift
				;;
			--motion=*)
				_arg_motion="${_key##--motion=}"
				;;
			-m*)
				_arg_motion="${_key##-m}"
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'video'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_video "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


echo "Crunching $_arg_video"
if [[ $_arg_video =~ (.*\/)([0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-9]{2})-.*.mp4$ ]]; then
  _path=${BASH_REMATCH[1]}
  _prefix=${BASH_REMATCH[2]}
  echo "  Valid Tesla format - $_prefix"

  _highlight=${_path}${_prefix}-highlight.gif
  if [[ -f $_highlight ]]; then
    echo "  Previously crunched, skipping."
    exit 0
  fi

  _files="front right_repeater left_repeater"

  # Verify files are present and of consistent length
  _target_length=0
  for v in $_files; do
    _original=${_path}${_prefix}-${v}.mp4
    if [[ -f $_original ]]; then
      _length=$(printf "%.0f" $(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 $_original))
      if [ $_target_length -eq 0 ]; then
        _target_length=$_length
      fi
      if [ $_length -ge $(($_target_length-1)) ] && [ $_length -le $(($_target_length+1)) ]; then
        echo "  $v valid"
      else
        echo "  $v Invalid length - $_length, expecting $_target_length"
        exit 1
      fi
    else
      echo "  $v doesn't exist"
      exit 1
    fi
  done

  # Resize originals to something that we can handle on pi RAM
  for v in $_files; do
    _original=${_path}${_prefix}-${v}.mp4
    _shrunk=${_path}${_prefix}-${v}_small.mp4
    if [[ ! -f $_shrunk ]]; then
      _temp=${_shrunk}.temp.mp4
      echo "  Compressing $_shrunk"
      ffmpeg -i "$_original" -nostdin -loglevel panic -s 320x240 -c:a copy "$_temp"
      mv "$_temp" "$_shrunk"
    fi
  done
  
  if [[ ! -f $_highlight ]]; then
    _front=${_path}${_prefix}-front_small.mp4
    _left=${_path}${_prefix}-left_repeater_small.mp4
    _right=${_path}${_prefix}-right_repeater_small.mp4
    echo "  Crunching - $_prefix..."
    _crunch=${_path}${_prefix}-crunch.mp4
    _temp=${_highlight}.temp.gif
    ffmpeg -y -i $_right -i $_front -i $_left -nostdin -loglevel panic -filter_complex \
      "[0:v][1:v]hstack[lf];[lf][2:v]hstack[lfr];[lfr]split[full][f];[f]select=gt(scene\,$_arg_motion),setpts=N/(16*TB)[bh];[bh]scale=w=600:h=150[hslow];[hslow]setpts=0.25*PTS[highlight]" \
      -map "[full]" -pix_fmt yuv420p $_crunch -map "[highlight]" -pix_fmt yuv420p $_temp
    if [ $? -eq 0 ]; then
    _lengthc=$(printf "%.0f" $(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 $_crunch))
      if [ $_lengthc -lt $_target_length ]; then
        echo "  Crunch failed with unexpected length $_lengthc"
        exit 1
      fi
      echo "  Crunched $_crunch!"
      mv $_temp $_highlight
      rm ${_path}${_prefix}*_small.mp4
    else
      echo "  Crunch failed :("
    fi
  fi
else
  echo "Invalid file name format"
fi

# ] <-- needed because of Argbash